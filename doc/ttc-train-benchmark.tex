\documentclass[submission]{eptcs}
\providecommand{\event}{TTC 2015}

\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{varioref}
\usepackage{hyperref}
\usepackage{paralist}
\usepackage[cache]{minted}
\newminted{clojure}{fontsize=\fontsize{8}{8},linenos,numbersep=3pt,numberblanklines=false}
\newmintinline{clojure}{fontsize=\footnotesize}
\newcommand{\code}{\clojureinline}

\title{Solving the TTC Train Benchmark Case with FunnyQT}
\author{Tassilo Horn
  \institute{Institute for Software Technology, University Koblenz-Landau, Germany}
  \email{horn@uni-koblenz.de}}

\def\titlerunning{Solving the TTC Train Benchmark Case with FunnyQT}
\def\authorrunning{T. Horn}

\begin{document}
\maketitle

\begin{abstract}
  FunnyQT is a model querying and model transformation library for the
  functional Lisp-dialect Clojure providing a rich and efficient querying and
  transformation API.  This paper describes the FunnyQT solution to the TTC
  2015 Train Benchmark transformation case which solves all core tasks and all
  extension tasks.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

This paper describes the FunnyQT\footnote{\url{http://funnyqt.org}}
~\cite{Horn2013MQWFQ} solution of the TTC 2015 Train Benchmark
Case~\cite{train-benchmark-case-desc}.  All core and extension tasks have been
solved.  The solution project is available on
Github\footnote{\url{https://github.com/tsdh/ttc15-train-benchmark-funnyqt}},
and it is set up for easy reproduction on a SHARE image\footnote{\url{FIXME:
    add SHARE URL}}.

FunnyQT is a model querying and transformation library for the functional Lisp
dialect Clojure\footnote{\url{http://clojure.org}}.  Queries and
transformations are plain Clojure programs using the features provided by the
FunnyQT API.  This API is structured into several task-specific
sub-APIs/namespaces, e.g., there is a namespace \emph{funnyqt.query} containing
model querying functions, \emph{funnyqt.in-place} containing constructs for
writing in-place transformations, a namespace \emph{funnyqt.model2model}
containing constructs for model-to-model transformations, a namespace
\emph{funnyqt.bidi} containing constructs for bidirectional transformations,
and several more.

FunnyQT is designed with extensibility in mind.  By default, it supports EMF
\cite{Steinberg2008EEM} models and
JGraLab\footnote{\url{http://jgralab.github.io}} TGraph models.  Support for
other modeling frameworks can be added without having to touch FunnyQT's
internals.

As a Lisp, Clojure provides strong metaprogramming capabilities that are
exploited by FunnyQT in order to define several \emph{embedded domain-specific
  languages} (DSL, \cite{book:Fowler2010DSL}) for different tasks.  For
example, the pattern matching/in-place transformation rule constructs used in
this solution is provided in terms of a task-oriented DSL.


\section{Solution Description}
\label{sec:solution-description}

In this section, the individual tasks are discussed one by one.  They are all
implemented as in-place transformation rules supported by FunnyQT's
\emph{funnyqt.in-place} transformation DSL.

\paragraph{Task 1: PosLength.}

The transformation rule realizing the \emph{PosLength} task is given below.

\begin{clojurecode}
(defrule ^:forall ^:recheck pos-length [g]
  [segment<Segment>
   :when (<= (eget-raw segment :length) 0)]
  (eset! segment :length (inc (- (eget-raw segment :length)))))
\end{clojurecode}

The \code|defrule| macro defines a new in-place transformation rule with the
given name (\code|pos-length|), formal parameters (\code|[g]|), a pattern
(\code|[segment<Segment>...]|), and one or many actions to be applied to the
pattern's matches (\code|(eset! ...)|).  The first formal parameter must denote
the model the rule is applied to, so here the argument \code|g| denotes the
train model when the rule is applied using \code|(pos-length my-train-model)|.

The pattern matches a node called \code|segment| of metamodel class
\code|Segment|.  Additionally, the segment's length must be less or equal to
zero.

The action says that the segment's \code|length| attribute should be set to the
incremented negation of the current length.

The normal semantics of applying a rule is to find one single match of the
rule's pattern and then execute the rule's actions on the matched elements.
The modifier \code|^:forall| changes this behavior to finding all matches
first, and then applying the actions to each match one after the other.
FunnyQT automatically parallelizes the pattern matching process of such
forall-rules under certain circumstances like the JVM having more than one CPU
available and the pattern declaring at least two elements to be matched.

The \code|^:recheck| modifier causes the rule to re-check if a pre-calculated
match is still conforming the pattern just before executing the rule's actions
on it.  This can be needed for forall-rules whose actions possibly invalidate
matches of the same rule's pattern, e.g., when the application of the action to
a match \(m_i\) cause another match \(m_j\) to be no valid match any longer.


\paragraph{Task 2: SwitchSensor.}

The transformation rule realizing the \emph{SwitchSensor} task is given below.

\begin{clojurecode*}{firstnumber=5}
(defrule ^:forall ^:recheck switch-sensor [g]
  [sw<Switch> -!<:sensor>-> <>]
  (eset! sw :sensor (ecreate! nil 'Sensor)))
\end{clojurecode*}

It matches a \code|Switch| \code|sw| which is not contained by some sensor.
The exclamation mark of the edge symbol \code|-!<:sensor>->| specifies that no
such reference must exist, i.e., it specifies a negative application condition.

The action fixes this problem simply by creating a new \code|Sensor| and
assigning that to the switch \code|sw|.


\paragraph{Task 3: SwitchSet.}

The \code|switch-set| rule realizes the \emph{SwitchSet} task.  Its definition
is given below.

\begin{clojurecode*}{firstnumber=8}
(def Signal-GO (eenum-literal 'Signal.GO))

(defrule ^:forall ^:recheck switch-set [g]
  [route<Route> -<:entry>-> semaphore
   :when (= (eget-raw semaphore :signal) Signal-GO)
   route -<:follows>-> swp -<:switch>-> sw
   :let [swp-pos (eget-raw swp :position)]
   :when (not= (eget-raw sw :currentPosition) swp-pos)]
  (eset! sw :currentPosition swp-pos))
\end{clojurecode*}

It matches a \code|route| with its entry \code|semaphore| where the semaphore's
signal is \code|Signal.GO|.  The route follows some switch position \code|swp|
whose switch's current position is different from that of the switch position.

The fix is to set the switch's current position to the position of the switch
position \code|swp|.

Note that there are no metamodel types specified for the elements
\code|semaphore|, \code|swp|, and \code|sw| because those are already defined
implicitly by the references leading to them, e.g., all elements referenced by
a route's \code|follows| can only be instances of \code|SwitchPosition|
according to the metamodel.  Thus, FunnyQT doesn't require the transformation
writer to encode tautologies in her patterns\footnote{In fact, if there are
  types specified, those will be checked.  So omitting them when they are not
  needed also results in slightly faster patterns.}.


\paragraph{Extension Task 1: RouteSensor.}

The extension task \emph{RouteSensor} is realized by the \code|route-sensor|
rule given below.

\begin{clojurecode*}{firstnumber=16}
(defrule ^:forall ^:recheck route-sensor [g]
  [route<Route> -<:follows>-> swp -<:switch>-> sw
   -<:sensor>-> sensor --!<> route]
  (eadd! route :definedBy sensor))
\end{clojurecode*}

It matches a \code|route| that follows some switch position \code|swp| whose
switch \code|sw|'s \code|sensor| is not contained by the \code|route|.

The repair action is to assign the \code|sensor| to the \code|route|.


\paragraph{Extension Task 2: SemaphoreNeighbor.}

The second extension task \emph{SemaphoreNeighbor} is realized by the
\code|semaphore-neighbor| rule defined as shown below.

\begin{clojurecode*}{firstnumber=20}
(defrule ^:forall ^:recheck semaphore-neighbor [g]
  [route1<Route> -<:exit>-> semaphore
   route1 -<:definedBy>-> sensor1 -<:elements>-> te1
   -<:connectsTo>-> te2 -<:sensor>-> sensor2
   --<> route2<Route> -!<:entry>-> semaphore
   :when (not= route1 route2)]
  (eset! route2 :entry semaphore))
\end{clojurecode*}

It matches a route \code|route1| which has an exit \code|semaphore|.
Additionally, \code|route1| is defined by a sensor \code|sensor1| which
contains some track element \code|te1| that connects to some track element
\code|te2| whose sensor is \code|sensor2|.  This \code|sensor2| is contained by
some other route \code|route2| which does not have \code|semaphore| as entry
semaphore.

The fix is to set \code|route2|'s entry reference to \code|semaphore|.


\subsection{Deferred Rule Actions}
\label{sec:deferred-actions}

As already mentioned above, the normal semantics of a forall-rule is to compute
all matches of the rule's pattern first (possibly in parallel), and then apply
the rule's actions on every match one after the other.  However, the case
description strictly separates the computation of matches from the repair
transformations.

FunnyQT also provides stand-alone patterns.  Using them, one could have defined
patterns for finding occurrences of the five problematic situations in a train
model, and separate functions for the repair actions where the latter receive
one match of the corresponding pattern and fix that.

But for in-place transformation rules, FunnyQT also provides \emph{rule
  application modifiers}.  Concretely, any in-place transformation rule
\code|r| can be called as \code|(as-pattern (r model))| in which case it
behaves as a pattern.  That is, where a normal rule would usually find one
match and apply its actions on it and a forall-rule would usually find all
matches and apply its actions to each of them, when called with
\code|as-pattern|, a rule simply returns the sequence of its matches.  With a
normal rule, this sequence is a lazy sequence, i.e., the matches are not
computed until they are consumed.  With a forall-rule, the sequence is fully
realized, i.e., all matches are already precalculated.

The second FunnyQT rule application modifier is \code|as-test|, and this is
what is highly suitable for this transformation case.  When a rule \code|r| is
applied using \code|(as-test (r model))|, it behaves almost as without modifier
but instead of applying the rule's actions immediately, it returns a closure of
arity zero (a so-called \emph{thunk}) which captures the rule's match and the
rule's actions.  Invoking the thunk causes the actions to be applied on the
match.  Thus, the the caller who applied the rule as a test gets the
information if the rule was applicable at all, and if it was applicable, he can
decide if he wants to apply it or not.  And when he applies it, the pattern
matching part is already finished and only the actions are applied on the
pre-calculated match or matches the thunk closes over.  The following snippet
illustrates the behavior.

\begin{clojurecode*}{numbers=none}
(if-let [thunk (as-test (rule model))]
  (if (< (Math/random) 0.5)
    (thunk) ;; The rule was applicable, and here its actions are executed
    (println "The coin toss decided to skip the rule application"))
  (println "The rule is not applicable"))
\end{clojurecode*}

One interesting point is that the thunk returned by calling a rule as a test
has some metadata attached\footnote{Almost any Clojure object (functions,
  symbols, vars, collections, etc.) can have metadata attached.  Metadata
  doesn't affect equality, i.e., two Clojure objects that differ only in their
  metadata are still equal.}.  For this TTC case, only the \code|:match|
metadata entry is important.  As its name suggests, its value is the match of
the rule on which the thunk applies the rule's actions.

In case of a forall-rule \code|r|, \code|(as-test (r model))| doesn't return a
single thunk but a vector of thunks -- one thunk per match of the rule's
pattern.  This is exactly what is needed for solving this transformation case.

Finally, a function is defined that receives a rule \code|r| and a train model
\code|g| and executes the rule as a test.

\begin{clojurecode*}{firstnumber=27}
(defn call-rule-as-test [r g]
  (as-test (r g)))
\end{clojurecode*}

This is only needed in order to be able to call the rules as tests from Java.
The reason is that only functions (and rules which are functions, too) can be
referred to from Java but \code|as-test| is a macro which does its magic at
compile-time.

These 28 lines of Clojure code form the complete functional part of the FunnyQT
solution that solves all core and extension tasks.  The comparator used for
sorting the matches in the benchmark framework is also implemented using
Clojure/Funnyqt and discussed in \vref{sec:match-comparison}.  Additionally,
there is a plain-Java glue project which implements the interfaces required by
the framework and simply delegates to the Clojure/FunnyQT part of the solution.
This glue project is briefly discussed in \vref{sec:gluing}.


\subsection{Match Comparison}
\label{sec:match-comparison}

The case description demands that solutions provide comparators that are to be
used for sorting matches.  All comparators simply compare two matches element
by element with respect to the values of the \textsf{id}-attribute.  The order
in which the elements of two matches have to be compared is defined separately
for each task.

Instead of providing one comparator per task, the FunnyQT solution provides one
function \code|make-match-comparator| which receives the names of the match
elements to be compared and then returns a suitable comparator.  The function's
definition is given below.

\begin{clojurecode}
(defn make-match-comparator [& kws]
  (fn [t1 t2]
    (loop [kws kws]
      (if (seq kws)
        (let [m1 ((first kws) (:match (meta t1)))
              m2 ((first kws) (:match (meta t2)))]
          (let [r (compare (eget m1 :id) (eget m2 :id))]
            (if (zero? r)
              (recur (rest kws))
              r)))
        (errorf "These two matches compare to zero: %s %s"
                (:match (meta t1))
                (:match (meta t2)))))))
\end{clojurecode}

The \code|make-match-comparator| function is to be used as follows.

\begin{clojurecode*}{numbers=none}
(make-match-comparator :segment)
;=> comparator for pos-length
(make-match-comparator :sw)
;=> comparator for switch-sensor
(make-match-comparator :semaphore :route :swp :sw)
;=> comparator for switch-set
(make-match-comparator :route :sensor :swp :sw)
;=> comparator for route-sensor
(make-match-comparator :semaphore :route1 :route2 :sensor1 :sensor2 :te1 :te2)
;=> comparator for semaphore-neighbor
\end{clojurecode*}


\code|make-match-comparator| returns a function of two arguments.  In Clojure,
every function implements the \code|java.util.Comparator| interface and thus
any function of two arguments which returns an integer can be used as such.



The returned comparator function receives two thunks \code|t1| and \code|t2|.
Then it iterates the keywords denoting the matched element names.  Lines 5 and
6 extract the actual elements of the thunks' matches which are denoted by the
first keyword.  Then line 7 compares the \textsf{id} attribute values.  If the
comparison returns a non-zero value and thus these elements are different, it
is simply returned.  Otherwise, the remaining keywords are tested one after the
other.  If no distinction between matches can be made after considering all
given keywords, an error is signaled.



\subsection{Gluing the Solution with the Framework}
\label{sec:gluing}



\section{Evaluation and Conclusion}
\label{sec:evaluation}

\bibliographystyle{eptcs}
\bibliography{ttc-train-benchmark}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-extra-options: "-shell-escape"
%%% End:

%  LocalWords:  parallelizes
